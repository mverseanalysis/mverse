---
title: "Defining a branch for a column and extracting the branched values."
output: rmarkdown::html_vignette
link-citations: yes
vignette: >
  %\VignetteIndexEntry{Defining a branch for a column and extracting the branched values.}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
references:
  - id: datasrc
    title: "Many analysts, one dataset: Making transparent how variations in anlytical choices affect results"
    type: entry
    issued:
      year: 2014
      month: 4
      day: 24
    accessed:
      year: 2019
    URL: https://osf.io/gvm2z/
    author:
    - given: Raphael 
      family: Silberzahn 
    - given: "Eric Luis" 
      family: Uhlmann 
    - given: Dan 
      family: Martin 
    - given: Pasquale 
      family: Anselmi 
    - given: Frederik 
      family: Aust 
    - given: "Eli C."
      family: Awtrey
    - given: Štěpán
      family: Bahník 
    - given: Feng
      family: Bai 
    - given: Colin
      family: Bannard
    - given: Evelina
      family: Bonnier
    - given: Rickard
      family: Carlsson
    - given: Felix
      family: Cheung
    - given: Garret
      family: Christensen
    - given: Russ
      family: Clay
    - given: "Maureen A."
      family: Craig
    - given: Anna 
      family: "Dalla Rosa"
    - given: Lammertjan
      family: Dam
    - given: "Mathew H."
      family: Evans
    - given: "Ismael Flores"
      family: Cervantes
    - given: Nathan
      family: Fong
    - given: Monica
      family: Gamez-Djokic
    - given: Andreas
      family: Glenz
    - given: Shauna
      family: Gordon-McKeon
    - given: Tim
      family: Heaton
    - given: "Karin Hederos" 
      family: Eriksson 
    - given: Moritz
      family: Heene
    - given: "Alicia Hofelich"
      family: Mohr 
    - given: Kent
      family: Hui
    - given: Magnus
      family: Johannesson
    - given: Jonathan
      family: Kalodimos
    - given: Erikson
      family: Kaszubowski
    - given: Deanna
      family: Kennedy
    - given: Ryan
      family: Lei
    - given: "Thomas Andrew"
      family: Lindsay
    - given: Silvia
      family: Liverani
    - given: Christopher
      family: Madan
    - given: "Daniel C."
      family: Molden 
    - given: Eric 
      family: Molleman
    - given: "Richard D."
      family: Morey
    - given: Laetitia
      family: Mulder
    - given: "Bernard A." 
      family: Nijstad
    - given: Bryson
      family: Pope
    - given: Nolan
      family: Pope
    - given: "Jason M."
      family: Prenoveau
    - given: Floor
      family: Rink
    - given: Egidio
      family: Robusto
    - given: Hadiya
      family: Roderique
    - given: Anna
      family: Sandberg
    - given: Elmar
      family: Schlueter
    - given: Felix
      family: S
    - given: "Martin F." 
      family: Sherman
    - given: "S. Amy"
      family: Sommer
    - given: "Kristin Lee"
      family: Sotak
    - given: "Seth M."
      family: Spain
    - given: Christoph
      family: Spörlein 
    - given: Tom
      family: Stafford
    - given: Luca
      family: Stefanutti
    - given: Susanne
      family: Täuber
    - given: Johannes
      family: Ullrich
    - given: Michelangelo 
      family: Vianello 
    - given: Eric-Jan 
      family: Wagenmakers 
    - given: Maciej 
      family: Witkowiak 
    - given: Sangsuk 
      family: Yoon 
    - given: Brian A. 
      family: Nosek
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(mverse)
```

In this example, we demonstrate `mverse` makes it easy to define multiple definitions for a column in a dataset and compare the results of the different definitions. For the demonstration, we combine soccer player skin colour ratings by two independent raters (`rater1` and `rater2`) from `soccer` dataset included in the library. 

## Introduction

The data comes from @datasrc and contains `r format(nrow(soccer), big.mark = ",")` rows of player-referee pairs. For each player, two independent raters coded their skin tones on a 5-point scale ranging from _very light skin_ (`0.0`) to _very dark skin_ (`1.0`). For the purpose of demonstration, we only use a unique record per player and consider only those with both ratings.

```{r load, message=FALSE}
library(mverse)
df <- soccer[!is.na(soccer$rater1) & !is.na(soccer$rater2), 
             c('playerShort', 'rater1', 'rater2')]
df <- unique(df)
head(df)
```

We would like to study the distribution of the player skin tones but the two independent rating do not always match. To combine the two ratings, we may choose to consider the following options:

1.  the mean numeric value
2.  the darker rating of the two
3.  the lighter rating of the two
4.  the first rating only
5.  the second rating only

## Without the `mverse` library

Let's first consider how you might study the five options using base R. First, we define the five options as separate variables in R.

```{r base_r}
skin_option_1 <- (df$rater1 + df$rater2) / 2 
skin_option_2 <- ifelse(df$rater1 > df$rater2, df$rater1, df$rater2)
skin_option_3 <- ifelse(df$rater1 < df$rater2, df$rater1, df$rater2)
skin_option_4 <- df$rater1    
skin_option_5 <- df$rater2    
```

We can plot a histogram to study the distribution of the resulting skin tone value for each option. Below is the histogram for the first option (`skin_option_1`).

```{r hist_base}
library(ggplot2)
ggplot(mapping=aes(x = skin_option_1)) +
  geom_histogram(breaks = seq(0,1,0.2),
                 colour = 'white') +
  labs(title = 'Histogram of player skin tones (Option 1: Mean).',
       x = 'Skin Tone', y = 'Count')
```


For the remaining four options, we can repeat the step above to examine the distributions, or create a new data frame combining all five options to use in a ggplot as shown below. In both cases, users need to take care of plotting all five manually.

```{r hist_base_overlaid}
skin_option_all <- data.frame(
  x = c(skin_option_1, skin_option_2, skin_option_3, skin_option_4, skin_option_5),
  Option = rep(c(
    'Option 1: Mean', 'Option 2: Max', 'Option 3: Min', 
    'Option 4: Rater 1', 'Option 5: Rater 2'), each = nrow(df)
    )
  )
ggplot(data = skin_option_all) +
  geom_histogram(aes(x = x), binwidth = 0.1) +
  labs(title = 'Histogram of player skin tones for each option.',
       x = 'Skin Tone', y = 'Count') +
  facet_wrap(. ~ Option)
```


## Branching using `mverse`

We now turn to `mverse` to create the five options above. First, we define a `mverse` object with the dataset. Note that `mverse` assumes a single dataset for each multiverse analysis.

```{r create_mv}
mv <- create_multiverse(df)
```

In `mverse` package, a _branch_ refers to a decision point in data analysis where you may consider more than one _option_. For example, a mutate branch - analogous to `mutate` method in `tidyverse`'s data manipulation grammar, lets you define a set of options for defining a new column in your dataset. 

You can create a mutate branch with `mutate_branch()`. The syntax for defining the options inside `mutate_branch()` follows the `tidyverse`'s grammar as well. 

```{r mutate_branch}
skin_tone <- mutate_branch(
  (rater1 + rater2)/2,
  ifelse(rater1 > rater2, rater1, rater2),
  ifelse(rater1 < rater2, rater1, rater2),
  rater1,
  rater2
)
```

You can then add the newly defined mutate branch to the `mv` object using `add_mutate_branch()`. 

```{r add_vb}
mv <- mv %>%
  add_mutate_branch(skin_tone)
```

Adding a branch to a `mverse` object multiplies the number of environments defined inside the object so that the environments capture all unique analysis paths. Without any branches, a `mverse` object has a single environment. We call these environments _universes_. For example, adding the `skin_tone` mutate branch to `mv` results in $1 \times 5 = 5$  universes inside `mv`. In each universe, the analysis dataset now has a new column named `skin_tone` -  the name of the mutate branch object. 

You can check that the mutate branch was added with `summary()` method for the `mv` object. The method prints a _multiverse table_ that lists all universes with branches as columns and corresponding options as values defined in the `mv` object.

```{r check_multiverse}
summary(mv)
```

At this point, the values of the new column `skin_tone` are only populated in the first universe. To populate the values for all universes, we call `execute_multiverse`.

```{r exec}
execute_multiverse(mv)
```

## Comparing between universes

In this section, we now examine and compare the distributions of `skin_tone` values between different options. You can extract the values in each universe using `extract()`. By default, the method returns all columns created by a mutate branch across all universes. In this example, we only have one column - `skin_tone`.

```{r extract_multiverse}
branched <- extract(mv)
```

`branched` is dataset with `skin_tone` values from the first universe...

```{r head_skin_tone}
head(branched)
```

...as well as the last universe.

```{r tail_skin_tone}
tail(branched)
```

The method provides various options to select a subset of data as well. These are useful when the multiverse is too large and examining the whole multiverse is inefficient.

Setting `universe = 2` extracts values from the second universe only. Checking the unique `universe` values in the returned dataset shows that the dataset indeed only consists of values from the second universe. 

```{r ununi}
branched_2 <- extract(mv, universe = 2)
unique(branched_2$universe)
```

Setting `universe = c(1,2)` extracts values from both first and second universes.

```{r ununi_1_2}
branched_1_2 <- extract(mv, universe = c(1,2))
unique(branched_1_2$universe)
```

`frow` provides the option to extract a random subset of rows in each universe. It takes a value between 0 and 1 that represent the fraction of values to extract from each universe. For example, setting `frow = 0.05` returns approximately 5\% of values from each universe.

```{r extract_fraction}
frac <- extract(mv, frow =  0.05)
```

`frac` consists of values that are approximately 5\% of the first universe...

```{r check_frac_1}
sum(frac$universe == 1)/sum(branched$universe == 1)
```

...plus approximately 5\% of the second universe...

```{r check_frac_2}
sum(frac$universe == 2)/sum(branched$universe == 2)
```

...and so on.

```{r check_frac_all}
sum(frac$universe == 3)/sum(branched$universe == 3)
sum(frac$universe == 4)/sum(branched$universe == 4)
sum(frac$universe == 5)/sum(branched$universe == 5)
```

Finally, we can construct plots to compare the distributions of `skin_tone` in different universes. For example, you can overlay density lines on a single plot.

```{r compare_universe, warning=FALSE}
branched %>%
  ggplot(mapping = aes(x = skin_tone, color = universe)) +
  geom_density(alpha = 0.2) +
  labs(title = 'Density of player skin tones for each option.',
       x = 'Skin Tone', y = 'Density') +
  scale_color_discrete(labels = c(
    'Option 1: Mean', 'Option 2: Max', 'Option 3: Min', 
    'Option 4: Rater 1', 'Option 5: Rater 2'),
    name = NULL
  )
```

Another option is the use `ggplot`'s `facet_grid` function to generate multiple plots in a grid. `facet_wrap(. ~ universe)` generates individual plots for each universe.

```{r compare_universe_hist, warning=FALSE}
branched %>%
  ggplot(mapping = aes(x = skin_tone)) +
  geom_histogram(position = 'dodge', bins = 21) +
  labs(title = 'Histogram of player skin tones for each option.',
       y = 'Count', x='Skin Tone') + 
  facet_wrap(
    . ~ universe, 
    labeller = labeller(univrse = c(
    'Option 1: Mean', 'Option 2: Max', 'Option 3: Min', 
    'Option 4: Rater 1', 'Option 5: Rater 2'))
  ) 
```



## References
